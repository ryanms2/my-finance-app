generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String                   @id @default(cuid())
  name                    String?
  email                   String?                  @unique
  emailVerified           DateTime?
  image                   String?
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  password                String?
  accounts                Account[]
  Authenticator           Authenticator[]
  budgets                 Budget[]
  categories              Category[]
  notifications           Notification[]
  notificationPreferences NotificationPreferences?
  pushSubscriptions       PushSubscription[]
  RecurringTransaction    RecurringTransaction[]
  sessions                Session[]
  tags                    Tag[]
  transactions            Transaction[]
  transfers               Transfer[]
}

model Account {
  id                   String                 @id @default(cuid())
  userId               String
  name                 String
  type                 String
  institution          String?
  accountNumber        String?
  balance              Float?
  totalLimit           Float?
  color                String?
  isDefault            Boolean                @default(false)
  provider             String?
  providerAccountId    String?
  refresh_token        String?
  access_token         String?
  expires_at           Int?
  token_type           String?
  scope                String?
  id_token             String?
  session_state        String?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  user                 User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  RecurringTransaction RecurringTransaction[]
  transactions         Transaction[]
  transfersFrom        Transfer[]             @relation("TransferFrom")
  transfersTo          Transfer[]             @relation("TransferTo")

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime
  id         String   @id @default(cuid())

  @@unique([identifier, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  user                 User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model Category {
  id                   String                 @id @default(cuid())
  name                 String
  type                 String
  color                String?
  icon                 String?
  userId               String?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  budgets              Budget[]
  user                 User?                  @relation(fields: [userId], references: [id])
  RecurringTransaction RecurringTransaction[]
  transactions         Transaction[]
}

model Transaction {
  id          String                @id @default(cuid())
  description String
  amount      Float
  date        DateTime
  type        String
  userId      String
  accountId   String
  categoryId  String
  recurringId String?
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  attachments Attachment[]
  account     Account               @relation(fields: [accountId], references: [id])
  category    Category              @relation(fields: [categoryId], references: [id])
  recurring   RecurringTransaction? @relation(fields: [recurringId], references: [id])
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags        Tag[]                 @relation("TransactionTags")
}

model Budget {
  id         String   @id @default(cuid())
  userId     String
  categoryId String
  amount     Float
  month      Int
  year       Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  category   Category @relation(fields: [categoryId], references: [id])
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId, month, year])
}

model RecurringTransaction {
  id           String        @id @default(cuid())
  description  String
  amount       Float
  frequency    String
  nextRun      DateTime
  userId       String
  accountId    String
  categoryId   String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  account      Account       @relation(fields: [accountId], references: [id])
  category     Category      @relation(fields: [categoryId], references: [id])
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[]
}

model Tag {
  id           String        @id @default(cuid())
  name         String
  color        String?
  userId       String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[] @relation("TransactionTags")
}

model Transfer {
  id            String   @id @default(cuid())
  description   String?
  amount        Float
  date          DateTime
  userId        String
  fromAccountId String
  toAccountId   String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  fromAccount   Account  @relation("TransferFrom", fields: [fromAccountId], references: [id])
  toAccount     Account  @relation("TransferTo", fields: [toAccountId], references: [id])
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Attachment {
  id            String      @id @default(cuid())
  url           String
  transactionId String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
}

model Notification {
  id         String    @id @default(cuid())
  userId     String
  type       String
  title      String
  message    String
  priority   String
  channels   String
  data       String?
  read       Boolean   @default(false)
  actionUrl  String?
  actionText String?
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([userId, createdAt])
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String
  p256dh    String
  auth      String
  userAgent String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
}

model NotificationPreferences {
  id                String   @id @default(cuid())
  userId            String   @unique
  enableInApp       Boolean  @default(true)
  enablePush        Boolean  @default(true)
  enableEmail       Boolean  @default(false)
  budgetAlerts      Boolean  @default(true)
  transactionAlerts Boolean  @default(true)
  securityAlerts    Boolean  @default(true)
  marketingAlerts   Boolean  @default(false)
  quietHours        String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
